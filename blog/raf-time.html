<!DOCTYPE html>
<html lang="en">
    <head>
          <title>NickNagel.com - Time-Based Animation in Javascript using RequestAnimationFrame</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <script>
            MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']]
                }
            };
        </script>
        <script 
            id="MathJax-script" 
            async 
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
        ></script>
        <!-- mermaid for class diagrams and UML... -->
        <script type="module">
            import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
            mermaid.initialize({ startOnLoad: true });
        </script>
        
          <script type="module" src="/scripts/dist_anim_controller/main.js"></script>

        
        <link 
            rel="stylesheet" 
            type="text/css" 
            href="/theme/css/styles.css" />
        <link 
            rel="stylesheet" 
            type="text/css" 
            href="/theme/css/admonitions.css" />
        <link 
            rel="stylesheet" 
            href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap" />




    <meta name="tags" content="javascript" />
    <meta name="tags" content="animation" />
    <meta name="tags" content="svg" />
    <meta name="tags" content="scalable vector graphics" />
    <meta name="tags" content="art" />
    <meta name="tags" content="artwork" />
    <meta name="tags" content="motion" />
    <meta name="tags" content="HTML5" />
    <meta name="tags" content="artworks" />
    <meta name="tags" content="framework" />
    <meta name="tags" content="Inkscape" />
    <meta name="tags" content="Illustrator" />
    <meta name="tags" content="Adobe" />

    </head>

    <body>

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg id="nn_symbols"
   version="1.1"
   style="display:none"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
   <defs>
    <symbol id="en_return"  viewBox="0 0 20 20">
      <path
        style="fill:#c83737;stroke:#751212;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
        d="M 9.6379516,18.516453 C 8.0412156,15.235727 5.9327077,14.722427 3.8797118,13.908944 L 9.6622123,2.3464436 15.149901,13.929683 c -2.648024,0.824695 -4.265949,1.397854 -5.5119494,4.58677 z"
        id="return_to_text_1"
      />
    </symbol>

    <symbol id="circle_symbol" viewBox="-7.5 -8 15 16">
      <circle id="circle_0"
        fill="currentColor"
        style="display:inline;"
        cx="0"
        cy="0"
        r="7.5"
      />
    </symbol>

    <symbol id="rectangle_symbol" viewBox="-7.5 -9 15 18">
      <rect
        fill="currentColor"
        style="display:inline;"
        id="rectangular_shape"
        width="15"
        height="18"
        x="-7.5"
        y="-9"
      />
    </symbol>

    <symbol id="diamond_symbol" viewBox="-7.5 -12 15 24">
      <rect
       fill="currentColor"
       style="display:inline;"
       id="diamond_0"
       width="15"
       height="15"
       x="-7.5"
       y="-7.5"
       transform="rotate(45)" />
    </symbol>

    <symbol id="triangle_symbol" viewBox="-7.5 -7.5 15 20">
      <path id="triangle_0"
        fill="currentColor"
        style="display:inline;"
        d="M -7.5,-7 7.5,-6.5763981 0.29315553,11 Z"
      />
    </symbol>

    <symbol id="oval_symbol" viewBox="-7 -10 14 20">
      <ellipse id="oval_0"
        fill="currentColor"
        style="display:inline;"
        cx="0"
        cy="0"
        rx="6"
        ry="9" />
    </symbol>

    <symbol id="heart_face_symbol" viewBox="-7.5 -10 15 20">
      <path id="heart_face"
          fill="currentColor"
          style="display:inline"
          d="M 7.5,-1.8272927 C 7.5,2.5909853 3.916407,6.7966536 -0.44632207,8 -4.5545331,6.1018628 -7.5,2.564393 -7.5,-1.853885 -7.5,-6.2721629 -4.4199989,-8 -0.44632207,-8 3.5273547,-8 7.5,-6.2455707 7.5,-1.8272927 Z"
      />
    </symbol>

   </defs>
</svg>
        <div class='banner'>
Welcome to NickNagel.com
        </div>
        <div class="container">
            <navbar class="navigation">
                <div class='image_item' id="pallas-athena-container">
                    <img id="pallas-athena-image"
                        src="/images/athena.svg" 
                        alt="Pallas Athena"
                    >
                </div>
                <ul>
                    <li>
                        <a href="/pages/about-nick.html">About Nick</a>
                    </li>
                    <li>
                        <a href="/blog/index.html">Blog</a>
                    </li>
                    <li>
                        <a href="/pages/nn-cv.html">CV</a>
                    </li>
                </ul>
            </navbar>
            <main class="content">
  <article>
    <header>
      <h2>
        <a href="/blog/raf-time.html" rel="bookmark"
           title="Permalink to Time-Based Animation in Javascript using RequestAnimationFrame">Time-Based Animation in Javascript using RequestAnimationFrame</a></h2>
      
    </header>
    <style>
.CodeList {
    background-color: #333;
    color: #FFE;
    padding: 5px;
    border: solid 1px black;
    border-radius: 5px;
    font-size: 10px;
}
.AlignCenter {
  text-align: center;
}

.CodeHighlight {
    color:#f99
}

.CodeLine{
    font-family: monospace;
    font-size: smaller;
    font-weight: bold;
    color: #A00;
}

.ImageWrapper {
    display: block;
    margin-right:auto;
    margin-left:auto;
    border: inset grey 4px;
}

.GuideWrapper { 
  display: flex;
  align-items: center; /* Vertically aligns items in the center */
}

.GuidePost {
  margin-left: 10px; /* Adds some spacing between the image and the text */
}


#oz_wrap {
    width:360px;
    margin-left: auto;
    margin-right: auto;
    text-align: center;

}

#oz_wrap svg{
    border: inset 3px #0a5
}

/* @keyframes twinkle {
  0%, 100% { opacity: 0.3; r: 1; }
  50% { opacity: 1; r: 10; }
} */

@keyframes sparkle-twinkle {
  0%, 100% {
    opacity: 0.3;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(5); /* 0.2 * 5 = 1.0 */
  }
}

.sparkle {
  transform-origin: center;
  animation: sparkle-twinkle 1.4s ease-in-out infinite;
}

.EndnoteReturn {
  width:  10px;
  height: 15px;
}

</style>

<h2>In this Post ...</h2>
<p>I'll discuss key aspects of SVG animation using javascript. In particular, I'll be focusing on time-dependent animation with *the <code>requestAnimationFrame</code> API. My purpose in doing so is to help artists, developers, AI's and anyone else who might be interested in creating with SVG. </p>
<h2>What is RAF?</h2>
<p>What exactly is RAF? RAF (<code>requestAnimationFrame</code>) is a web API designed to enable smooth rendering closely tied to browser based rendering engines. What follows is a guide to tying into the RAF framework to create animated content using SVG.</p>
<h2>The Animation Loop</h2>
<p>All animation occurs within a very basic loop. This was true from the inception of animated artworks from the early days of film with hand drawn images to modern day computer-based systems. At it's core, the animation loop can be expressed as follows:</p>
<pre>
WHILE animating:

    UPDATE animation state
        MOVE objects
        CHANGE properties 
        etc...

    RENDER the current frame
        (RE)DRAW objects at new positions/states
        DISPLAY the frame

    WAIT for an interval of time to elapse
</pre>

<p>In other words, all animation involves rendering a scene, waiting for an interval of time to pass, updating the scene, and rendering the updated imagery. Over and over again. </p>
<h2>Animation on the World Wide Web</h2>
<p>Back in the olden days, web-based animation could be implemented using just a few lines of javascript: </p>
<pre class="CodeList">
function animate() {
  while ( animating ) {
    update();
    render(); 
    setTimeout(animate, 50);
  }
}
</pre>

<p>Here, <code>update</code> would be a function defined to move things around and/or change object properties and <code>render</code> would be a function to draw to a renderable area like a 2D canvas. The <em>wait</em> period was achieved using javascript's <code>setTimeout</code> function. </p>
<p>Using this oldschool technique worked OK in the early years of WWW development. But used today it would probably result in janky animation. The reason is that <code>setTimeout</code> is not synchronized with the browser engine's rendering cycle, so using it to create delays can potentially lead to erratic updates and dropped frames appearing as flicker. </p>
<h1>RequestAnimationFrame</h1>
<p>The good news is that a better standard for animation was introduced way back in 2015 and has since become widely supported across all browser rendering engines. That is RAF. Specifically intended to enable smooth animation, <code>requestAnimationFrame</code> is optimized to operate in sync with the browser engine's rendering cycle. It is also worth noting that animation loops using RAF will pause when a user switches tabs or minimizes the animation window in order to reduce CPU utilization and battery usage. RAF is ideal for game-loops, AI simulations and any other use-cases requiring visual updates that need to be synchronized with browsers' rendering systems.</p>
<p>The following code shows an iteration of an animation controller I created early on to support interactive media experiences with SVG. </p>
<pre class="CodeList"><code class="language-javascript">
export const AnimationController = {
    previousTimestamp : 0 ,
    rafId : 0,

    update : function (timestamp)  {
        // compute delta time in SECONDS 
        const deltaTime = (timestamp - this.previousTimestamp) / 1000;
        this.previousTimestamp = timestamp;
        <span class='CodeHighlight'>GameController.updateSprites( deltaTime )</span>;
        this.rafId = <span class='CodeHighlight'>requestAnimationFrame( this.update.bind(this) )</span>;
    },

    startAnim : function  ()  {
        const  startTime = performance.now() ;
        this.previousTimestamp = startTime;
        this.update( startTime ) ;
    },

    stopAnim : function  ()  {
        <span class='CodeHighlight'>cancelAnimationFrame ( this.rafId ) ;</span>
        this.rafId = 0;
        const  stopTime = performance.now();
    },

}
</code></pre>

<p>The <code>AnimationController</code> exemplifies the application of the <code>requestAnimationFrame</code> API. It shows how the animation-loop can be implemented in javascript. Notice:</p>
<ol>
<li>
<p>The <code>update</code> method (a callback) receives a timestamp as input.</p>
</li>
<li>
<p><code>update</code> uses the timestamp to compute <em>the time delta between the current update and the previous frame</em>.</p>
</li>
<li>
<p>It then invokes <code>GameController</code> -- an object in the SVG Creators Collaborative &trade; framework for SVG artists -- an object responsible for (among other things) updating sprites. Notice how the AC passes the time delta to the game controller.</p>
</li>
<li>
<p>Finally, <code>update</code> calls <code>requestAnimationFrame</code> with a reference to itself, binding it as a <em>method</em> of the <code>AnimationController</code>.</p>
</li>
</ol>
<p>As defined in its API, <code>requestAnimationFrame</code> returns an id for the update, which can be used elsewhere should the request need to be canceled. The one thing you might've noticed though, is that there isn't an explicit <em>wait</em> parameter in the loop. That's where <code>deltaTime</code> comes in as I'll show in a bit.</p>
<h1>Examples</h1>
<p>'Time to look a couple of concrete examples. In this post I've narrowed the discussion to two kinds of time-based updates; <strong>frame-rate-independent</strong> and <strong>fixed-interval</strong>.</p>
<div class="admonition important">
<p class="admonition-title">Frame Rate</p>
<p><strong>Frame Rate</strong> refers to the frequency at which consecutive images, or <em>frames</em> are displayed in an animated sequence. Frame rate is measured in <em>frames per second</em> and taken as quotient of the number of frames divided by elapsed time:$$FPS = \frac{number\hspace{5px} of\hspace{5px} frames}{elapsed \hspace{5px} time}$$</p>
</div>
<h3>Frame-rate-independent updates</h3>
<p><em>Frame-rate-independent updates</em> are scheduled independently of the frame rate and are used typically to animate motion and physics simulations. As an example, I've inlined an animation of a certain <em>wicked witch</em> flying on her broom.</p>
<style>
#flight_container {
    width:350px;
    height:117px;
    border:inset 3px grey;
    margin-left: auto;
    margin-right: auto;
}

#flyer_control_panel {
    width:350px;

    margin-left: auto;
    margin-right: auto;
}

</style>
<div id="flight_container" 
    class="FlightContainer"
>
    <!-- INSERT FLYER -->
</div>
<div  id="flyer_control_panel">
    <button id="play_flight">Play</button>
    <!--
    <button id="update_button">Test</button>
    -->
    <span id="fps_display_move">FPS: 000</span>
</div>

<p>I created the animation by defining an SVG sprite and tapping into the animation controller logic through the SVG Creators Collaborative &trade; artists' framework. Within this framework, an SVG sprite can be defined by extending the <code>Moveable</code> class I've shown in the following diagram. </p>
<style>
.mermaid {
  /*
  transform: scale(0.85);
  transform-origin: top left;
  overflow: visible;
  color: red;
  */
  width: 200px;
  margin-left: auto;
  margin-right: auto;
}
</style>

<div class="mermaid" >
classDiagram
    class Moveable {
        +Vector2D pos
        +Vector2D vel
        +Vector2D acceleration
        +move(deltaTime)
        +isInBounds(rect)
    }

    class WickedSprite {
        +string id
        +SVGElement svg
        ...
        +wrap()
        +move(deltaTime)
        +renderFrame()
        +update(deltaTime)
    }

    Moveable <|-- WickedSprite
</div>

<p><span id="ret_1"><code>Moveable</code> encapsulates motion in the form of <em>position</em>, <em>velocity</em> and <em>acceleration</em> vectors. For frame-rate <em>independent</em> updates <code>move</code> can be called with <code>deltaTime</code> 
to scale the motion so that it looks consistent regardless of the frame rate (which can vary considerably in web browsers) <a href="#end_1"><sup>1</sup></a> </span>. </p>
<pre class="CodeList"><code class="language-javascript">
move ( deltaTime ) {
    this.vel.x += this.acceleration.x * deltaTime;
    this.vel.y += this.acceleration.y * deltaTime;
    this.pos.x += this.vel.x * deltaTime;
    this.pos.y += this.vel.y * deltaTime;
}
</code></pre>

<p>With this fedorated pattern, each sprite "knows" how it's supposed to move and can take care of itself on each update (as opposed to requiring "top down control" by the controller). </p>
<h3>Fixed Interval Updates</h3>
<style>
#billow_wrap {
    width: 200px;
    float: right;
    margin-left: 50px;
    margin-top: -20px;
}
</style>
<div id="billow_wrap">
    <div id="svg_container_billow" 
        class="BillowContainer" >
        <!-- INSERT WICKED CAPE SINE -->
    </div>
    <div  id="control_panel_billow">
        <button id="play_billow">Play</button>
        <button id="update_billow">Test</button>
        <span id="fps_display">FPS: 000</span>
    </div>
</div>

<p>Sometimes you need animation updates to occur on a fixed interval, or, <em>time-step</em>. This is especially important if you're makeing use of key-frames. Take for example this animation of our wicked witch's cape billowing in the wind. The animation makes use of <em>key-frames</em> to achieve the effect. </p>
<div class="admonition important">
<p class="admonition-title">Key frame Animation</p>
<p>Key frame animation is the technique of creating key <em>frames</em> depicting object shapes, poses, paths, etc. that occur over the course of a timeline. In the analog world animators create key-frames associated with key moments in a scene (e.g., a walk-cycle) and transition frames (referred to as "'tweens") are created to provide the illusion of motion. In the digital world key-frames are still needed to define key positions but interpolation <em>may</em> be achieved programmatically.</p>
</div>
<p><span id="ret_2">SVG artists might typically think of key-frame animation defined over SVG shapes. That's one of the beauties of SVG. It offers continuous path morphing (the capability to achieve perfectly smooth vector based transitions over time)  <a href="#end_2"><sup>2</sup></a> </span>. But with RAF you can also create sprite-based animation using the age-old approach of frame swapping as we see here. When might you want to do that in SVG? </p>
<ul>
<li>
<p>When the animation involves complex, organic, or unpredictable shape changes that are impossible to define with a fixed point count (e.g., liquid splashes, fire, highly detailed cloth simulations).</p>
</li>
<li>
<p>When you're going for a specific, non-interpolated "choppy" or traditional animation look for your aesthetic.</p>
</li>
<li>
<p>When you already have pre-rendered assets from another source.</p>
</li>
<li>
<p>When the performance of direct path morphing becomes an issue due to extreme path complexity.</p>
</li>
<li>
<p>When you need to incorporate raster-specific effects not easily done with SVG filters.</p>
</li>
</ul>
<p><span id="ret_3">Here are the keyframes I created for the billowing effect on Ms. Witch  <a href="#end_3"><sup>3</sup></a> </span> . </p>
<figure style="margin-left: 0;">
  <img src="/svg/svg_anim_raf/billow_keys.svg"
      title="Keyframes to Billow the Witch's Cape"
      alt="Key frames illustrating the sinusoidal billowing effect on the Wicked Witch of the West's Cape."
  ><br>
  <figurecaption>Figure: Keyframes used to achieve the billowing effect on the witch's cape.</figurecaption>
</figure>

<p>And now to the heart of it. <em>The trick to fixed-interval updates using the RAF API</em> is to: </p>
<ol>
<li>
<p>Specify your <strong>interval</strong>, and</p>
</li>
<li>
<p>Use an <strong>accumulator</strong> to trigger the changes.</p>
</li>
</ol>
<p>In this example I do that in the witch sprite's <code>update method</code>: </p>
<pre class="CodeList">
update( deltaTime ) {
    <span class='CodeHighlight'>this.accumulator += deltaTime;</span>
    while( this.accumulator >= this.fixedInterval ) {
        this.updateTransform();
        this.accumulator -= this.fixedInterval;
    }
}
</pre>

<p>Below I've created an animated diagram to illustrate how the accumulator works. </p>
<style>
#svg_container_diagram {
    /* width:200px;
    height:200px; */
    border:solid 3px red
}
</style>
<div id="fixed_interval_diagram" 
    class="SvgContainer" >
    <!-- INSERT DIAGRAM -->
</div>
<div  id="control_panel_diagram">
    <button id="play_widget">Run</button>
</div>

<p>The update function gets called in sync with browser update availability per the RAF specification. On each call the time delta between the current and previous calls is added to to the accumulator. Once the accumulator matches or exceeds the specified fixed interval the update function triggers changes to occur (e.g., sprite transformations) in lock-step with the interval. </p>
<h2>Discussion</h2>
<p>In this article my main intent was to focus on applying the javascript RAF API to animating SVG. Working through the examples showed how RAF provides an explicit mechanism to achieve smooth animation tied to the browser rendering-cycle. The API can be used to create anything from advertisments to production-quality video games for the Internet and World Wide Web.</p>
<p>Indeed, <code>requestAnimationFrame</code> is the absolute core of any browser-based animation loop. In video games, for example, whether it's done with SVG, HTML5 Canvas, or even WebGL/WebGPU 3D <em>every frame that gets rendered ultimately relies on</em> requestAnimationFrame <em>to trigger the update and render cycle</em>. Even sophisticated JavaScript game frameworks and engines that abstract away many low-level details for developers (like <em>Phaser</em>, <em>PixiJS</em>, <em>Three.js</em>, etc.) use RAF internally as their primary game-loop mechanism. They build on top of it. So having a strong feel for how it works is essential to any non-trivial animated graphics development for the Web.</p>
<h3>De-Coupling Timing From the Animation Loop</h3>
<p>As I hope to have shown, the RAF API de-couples timing from the animation loop in the sense that as an artist you don't have a fixed interval imposed your animation. Back in the olden days, analog animators were tied to a fixed frame-rate (e.g., 18 FPS) -- which is why all cartoon characters walked at the same rate ;D . In other words, all your key frames and tweens had to be calculated against the the fixed interval, so for cyclic animations like walk-cycles the keys had to be tied to clicks on the beat. </p>
<p>But as we saw, with RAF you get a chance to render everytime the browser refreshes its view. This carries with it a number of implications:</p>
<ol>
<li>
<p>You have to take steps to insure movement velocity is constant across varying frame rates, and </p>
</li>
<li>
<p>You have to insure you maintain a constant interval for frame-dependent animations. </p>
</li>
</ol>
<p>This adds a bit of complexity to your calculations for different types of animation. And introduces an important concept: <em>the animation timeline</em>. Deep diving into timelines will have to await future posts. But the good news is that with the extra bit of complexity using RAF at a low level you get a <em>lot</em> of creative freedom. Depending on what you are trying to accomplish, you  can adjust your timeline <em>independent</em> of the frame-rate you're working with to speed up or slow down cyclic animations. Smooooth bebe!</p>
<h3>A Few more things worth Noting</h3>
<h4>Material Thinking</h4>
<p>Here's a tip: </p>
<div class="admonition tip pro tip">
<p class="admonition-title">Tip</p>
<p>As you work to develop your artistic style using SVG -- in addition to worrying about color -- think about <em>materials</em>.</p>
</div>
<p>Elsewhere I've discused line, shape, color etc. with regard to <a href="/blog/svg-artworks.html">creating SVG art</a>. Here I want you to think about <em>light</em>. A huge part of the art of illustration in <em>any</em> medium involves understanding how light behaves. In creating the animations reflecting the nature of "real world objects" you want to think about what they're made of. By way of example, consider the rotating gear.</p>
<div style="width:120px; margin-left:20px;float:right">
    <img src="/svg/svg_anim_raf/gear_sprite_rotating.svg"
        title="Spinning Gear in SVG"
        alt="Thinking about light on a spinning gear."
    >
  </div>

<p>In addition to using a flat color to create the widget I also applied a gradient to convey a sense that the object is made of a matallic <em>material</em>. But be forwarned, a naive approach to creating sprites might entail applying a lot of hightlights without thinking about the end-game. The goal in creating this sprite at the end of the day was to animate it. The problem is when you start using effects like gradients and highlights you have to worry about dynamic consequences. Having the gradient rotate along with the underlying shape would look unnatural and odd. Light simply doesn't behave that way. In the real world, the light source is usually fixed. When objects move the highlights and shadows stay in place, while the object shape moves beneath them. This creates the impression of consistent lighting.</p>
<div class="admonition tip">
<p class="admonition-title">Bonus Tips: Simulating Light from a Direction</p>
<p>To make your SVG artworks look more natural match the gradient direction to the “light source” in your scene. Consider using <code>radialGradient</code>s, filter effects like <code>feDiffuseLighting</code>, and even <code>meshGradients</code>s to even greater effect. And in animation, <strong>decouple the animation of the shape from the gradient and associated highlights</strong>.</p>
</div>
<p>In other words, what if gradients in SVG (and other effects like blur, masking, etc.) were understood and structured more like virtual materials or surface shaders? Rather than binding them manually to IDs and linking them to shapes, what if your framework could introduce material descriptors -- reusable parameterized recipes that define how light behaves across a surface. And what if you had a framework and associated tooling and AI to make your life as an artist easier. Would you be interested?</p>
<h4>Animating Sprites</h4>
<p>In working through the creation of the <em>billowing cape effect</em> on the Wicked witch I briefly described the pattern where the fixed-interval for the animation was defined and managed <em>by the sprite herself</em> (as opposed to being implemented on the animation controller for example). Here's why this is a great idea:</p>
<ol>
<li>
<p><strong>The Single Responsibility Principle</strong>. If a sprite is in charge of its own behavior, then:</p>
<ul>
<li>It knows what kind of update it needs (kinetic motion, key-frame animation, AI, etc.)</li>
<li>It can decide whether to use <em>deltaTime</em>, a <em>fixed-step accumulator</em> SMIL, or any other means at is disposal to update.</li>
</ul>
</li>
<li>
<p><strong>Decoupling Modular Components</strong>. Your <em>Animation Controller</em> shouldn't have to know if a sprite is a particle, NPC, UI element, or a black hole for that matter. Each sprite can opt-in to the animation loop simply by providing an update to its view and thereby take charge of its own destiny.</p>
</li>
<li>
<p><strong>Scalability and Performance</strong>. Again, RAF decouples the animation time-line from the frame rate. This allows fine grained control over scalability and performance. Some sprites might animate at 24fps, others at 12. Or 60. Some sprites might not animate at all. Some might animate only while visible (room for optimization!)</p>
</li>
</ol>
<p>For these reasons I've adopted this pattern to create tooling and augment the framework for the SVG Creators Collaborative&trade;. Create thin controllers which notify and hand off reponsibilties to attentive observers. In essense, the controller can say: "It's time for the next tick, here's the time-delta from the last, go update yourself!" and leave it up to the sprite to figure out what to do. </p>
<p>To me, that's object-oriented zen. With this architecture we have the spine for something seriously dynamic. Imagine entire performances choreographed via procedural animation and AI. With this approach you get </p>
<ul>
<li>
<p>AI-driven behavioral refreshers based on simple behavioral principals (c.f., separation, alignment, cohesion)</p>
</li>
<li>
<p>Shared keyframe or gesture-sync across sprites</p>
</li>
<li>
<p>Blackboard/agent models for scalable decision-making</p>
</li>
<li>
<p>AI driven behavior blending (e.g., idle + follow + animate + signal in sync)</p>
</li>
<li>
<p>Procedural rhythm/sync engines (driven by tempo, music, emotional arc)</p>
</li>
</ul>
<p>The possibilities are endless.</p>
<h1>Conclusion</h1>
<p>In conclusion I hope to have shown in this article how the RAF API in combination with SVG provides a powerful set of tools for creating animated content for HTML5 powered engines. There are countless applications for such content spanning a range of categories including advertising, data visualization, video-games, simulations, interactive story telling and education just to name the broadest. So let me leave you with this thought; while animating SVG content comes with a unique set of challenges good things are coming down the pike in the form of tools and frameworks to make life easier for artists. Stay tuned for more to come!</p>
<div id="oz_wrap" >
    <!-- INSERT ART -->
</div>

<h1>Endnotes</h1>
<ol>
<li>
<p><span id="end_1">Please see my blog post on <a href="/blog/kinematics.html">kinematics</a> for more details on "moveables" <a href="#ret_1"><svg class="EndnoteReturn">
  <use href="#en_return"></use>
</svg></a></span> .</p>
</li>
<li>
<p><span id="end_2">It's both a blessing an a curse that SVG animation can be acheived in a number of ways. When the SVG spec was first release there was a grand vision of applying <strong>SMIL</strong> for animation <a href="/blog/svg-anim.html">which I was very excited and wrote about back then</a> . Later, when CSS3 was released, confusion arose through lack of understanding and appreciation of the creative potential afforded by SVG + SMIL. Confusion continues to this day with reports of the deprecation and demise of SMIL being greatly exaggerated. Often questions are raised, and ill-advised "answers" are still being posted favoring the use of CSS and/or javascript over SMIL. The fact is these advisements are often advanced under the rubrik of a false dichotemy. Should I use SMIL or javascript? As if these was an either/or proposition <a href="#ret_2"><svg class="EndnoteReturn">
  <use href="#en_return"></use>
</svg></a></span> . </p>
<p>The right answer is <em>both</em>. SMIL offer numerous benefits including:
<ol> 
  <li><strong>Portability.</strong> Since SMIL tags live inside the SVG animations can be defined in-line and dropped anywhere you can drop the SVG. Bang! Good to go!
  <li><strong>Independent time-lines.</strong> With independent time-lines on SMIL tags you can abtract away from RAF micromanagment (consistent, among other things, with the sprite update patterns discussed in the body of this article).
  <li><strong>Performance.</strong> SMIL is browser-native and automatically hardware-accelarated.
</ol></p>
<p>And if you are wondering whether SMIL is still supported look no further than this post. The animations I've created here contain a healthy mix of both RAF <em>and</em> SMIL and I can assure you they work great together.</p>
</li>
<li>
<p><span id='end_3'>Creating the billowing cloak turned out to be somewhat challenging. You can't just randomly morph points to get a good effect. For those who may be interested in the details look for my upcoming book on the intersection of SVG, artwork and AI. To forshadow, the effect benefitted from the application of some simple trigonometry <a href="#ret_3"><svg class="EndnoteReturn">
  <use href="#en_return"></use>
</svg></a></span> .</p>
</li>
</ol>
<h1>Resources</h1>
<ol>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame">RAF Documentation</a></p>
</li>
<li>
<p><a href="https://www.w3.org/TR/2001/REC-smil-animation-20010904/">SMIL Spec</a></p>
</li>
<li>
<p><a href="https://www.thriftbooks.com/w/the-animators-survival-kit-a-manual-of-methods-principles-and-formulas-for-classical-computer-games-stop-motion-and-internet-animators_richard---williams/264365/item/10214414/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=us_shopping_zombies_hvs_21811042479&amp;utm_adgroup=&amp;utm_term=&amp;utm_content=717524850233&amp;gad_source=4&amp;gad_campaignid=21811042479&amp;gbraid=0AAAAADwY45i6tC3D52at4v5jPOAsCJ3qy&amp;gclid=Cj0KCQjwjJrCBhCXARIsAI5x66X7hbZZ7A2bP9Hk4b0ieVkU_i4HjCrqX9hXOyxfJLDRZParsExoTGUaArWEEALw_wcB#idiq=10214414&amp;edition=8430392">Animator's Survival Kit</a></p>
</li>
</ol>
    <footer>
      <p>Published: <time datetime="2025-02-10T00:00:00-05:00">
        Mon 10 February 2025
      </time></p>
        <address>
          By             <a href="/author/nick-nagel.html">Nick Nagel</a>
        </address>
        <p>
          Category: <a href="/category/blog.html">blog</a>
        </p>
        <p>
          Tags:
            <a href="/tag/javascript.html">javascript</a>
            <a href="/tag/animation.html">animation</a>
            <a href="/tag/svg.html">svg</a>
            <a href="/tag/scalable-vector-graphics.html">scalable vector graphics</a>
            <a href="/tag/art.html">art</a>
            <a href="/tag/artwork.html">artwork</a>
            <a href="/tag/motion.html">motion</a>
            <a href="/tag/html5.html">HTML5</a>
            <a href="/tag/artworks.html">artworks</a>
            <a href="/tag/framework.html">framework</a>
            <a href="/tag/inkscape.html">Inkscape</a>
            <a href="/tag/illustrator.html">Illustrator</a>
            <a href="/tag/adobe.html">Adobe</a>
        </p>
    </footer>
  </article>
                <footer>
                    <hr />
                    <div class="footer_content">
Now built with <a rel="nofollow" href="https://getpelican.com/"><em>Pelican</em></a>,
which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                    </div>
                    <div class="copyright">
&copy; 1999-<span id="current-year"></span> Harold Nicholas Nagel. All rights reserved.  
                    </div>
                    <script>
document.getElementById("current-year").textContent = new Date().getFullYear();
                    </script>
                </footer>
            </main>
        </div>
    </body>
    
    
</html>